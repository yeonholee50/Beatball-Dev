#include "main.h"
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "images/intro.h"
#include "images/trollface.h"
#include "gba.h"
#include "loader.h"
#include "images/trademarklogo.h"

/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"



/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  PLAY,
  END
};


int main(void) {
  unsigned short bgcolor = BLACK;	
  int point = 0; //we go by point system and print out in end
  int ballRadius = 5;	
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;
  //struct ball ball;
  struct state cs, ps; //current state and previous state;
  struct baseState bcs, bps;
  struct base *p, *op;
  struct ball *bp, *obp;
  int randInteger = 0;
  int colRandInt = 0;
  char interString[12];
  //initialize buttons
  //save current and previous state of button input
  u32 previousButton = BUTTONS;
  u32 currentButton = BUTTONS;
  int status = 0;
  //load initial application state
  enum gba_state state = START;
  while(1) {
	currentButton = BUTTONS; //load current state of buttons



  	//keep track
	switch(state) {
		case START:
						
			//while (KEY_DOWN(BUTTON_START, currentButton) != 1) {
			waitForVBlank();
			//reset status
			status = 0;	
			//load title screen
			drawFullScreenImageDMA(intro);
			//reset dim and movement speed
			//bases initialization
			bcs.rowDim = BASEHEIGHT;
			bcs.colDim = BASEWIDTH;
			p = &bcs.bases;
			p->row = 140;
			p->col = WIDTH/2;
			p->cd = 0;
			p->color = RED;

			//ball initialization
			cs.size = ballRadius;
			bp = &cs.balls;
			bp->row = 0;
			bp->col = 0;
			bp->rd = 1;
			bp->cd = 1;
			bp->color = BLUE;


			//reset point
			point = 0;
			if(KEY_DOWN(BUTTON_START, currentButton)) {
				fillScreenDMA(bgcolor);
				state = PLAY;
				break;
			}
			break;
		case PLAY:	
			ps = cs;
			bps = bcs;


			//reset
			//if neither button is presed then this remains
			/*
			for (int i = 0; i < NBUTTONS; i++) {
				//buttonJustReleased[i] = KEY_DOWN(i, BUTTONS) == 0 && buttonWasDown[i];
				//buttonWasDown[i] = KEY_DOWN(i, BUTTONS) != 0;
				//KEY_JUST_PRESSED(i, BUTTONS, KEY_DOWN(i, BUTTONS));
				KEY_DOWN(i, BUTTONS);

			}
			*/
			
			if (KEY_DOWN(BUTTON_SELECT, currentButton)) {
				state = START;
				break;
			}	


			//if (buttonJustReleased[BUTTON_RIGHT]) {
			if (KEY_DOWN(BUTTON_RIGHT, currentButton)) {

				p->cd = 2;
			} else if (KEY_DOWN(BUTTON_LEFT, currentButton)) {				
			//} else if (buttonJustReleased[BUTTON_LEFT]) {
				p->cd = -2;
			} 
			delay(1);
	

			p = &bcs.bases;
			bp = &cs.balls;
			//bp->row += bp->rd;
			//bp->col += bp->cd;
			//p->col += p->cd;
			
			bp->row = bp->row + bp->rd;
			bp->col = bp->col + bp->cd;
			p->col = p->col + p->cd;

			//draw ball
			if (bp->row < 0) {
				bp->row = 0;
				bp->rd = -bp->rd;

			}
			if (bp->row > HEIGHT - cs.size) { //this is lose case - must fix so it disappears and exits gracefully
				bp->row = HEIGHT - cs.size;
				bp->rd = -bp->rd;
				state = END;
				obp = &ps.balls;
				//draws rectangular ball 
				drawRectDMA(obp->row, obp->col, ps.size, ps.size, bgcolor);
				op = &bps.bases;
				drawRectDMA(op->row, op->col, bps.colDim, bps.rowDim, bgcolor);
				drawString(20, 20, interString, bgcolor);
				break;
			}
			if(bp->col < 0) {
				bp->col = 0;
				bp->cd = -bp->cd;
			}
			if(bp->col > WIDTH - cs.size) {
				bp->col = WIDTH - cs.size;
				bp->cd = -bp->cd;
			}

			//if ball bounces off base, then it should react
			//cover all 4 dimensions: 
		
			//if it bounces off of left side of base 
			if ((bp->col + cs.size == p->col) && (bp->row > p->row) && (bp->row < p->row + BASEHEIGHT)) {
				bp->cd = -bp->cd;
			}
	
			//if it bounces off of right side of base
			if ((bp->col == p->col + BASEWIDTH) && (bp->row > p->row) && (bp->row < p->row + BASEHEIGHT)) {
				bp->cd = -bp->cd;
			}
	
	 

			//if it bounces off of top side of base
			if ((p->col <= bp->col) && (p->col + BASEWIDTH >= bp->col) && (p->row - cs.size <= bp->row + bp->rd)) {
				
				bp->row = p->row - cs.size;
				int oldRandInteger = randInteger;
				while(oldRandInteger == randInteger) { //gurantees different slope
					randInteger = randint(-3, -1); 
				}
				/*
				 * This process
				 */
				oldRandInteger = colRandInt;
		
				if (bp->cd > 0) {
					while(oldRandInteger == colRandInt) {
						colRandInt = randint(1, 3);
					}	
				} else if (bp->cd < 0) {
					while(oldRandInteger == colRandInt) {
						colRandInt = randint(-3, -1);
					}
				}

				point += bp->rd;
				if (randInteger + bp->row > p->row) {
					bp->rd = p->row - bp->row;
				} else {
					bp->rd = randInteger;
				}
				bp->cd = colRandInt;
			}

			
	
	
			//we should also make a lose condition where ball goes out of screen's botom
	
		
			//now we draw base moving //delete after succesfully doing buttons
			if (p->col < 0) {
				p->col = 0;
				//p->cd = -p->cd;	
			}
			if (p->col > WIDTH - BASEWIDTH) {
				p->col = WIDTH - BASEWIDTH;
				//p->cd = -p->cd;
			}

			char oldString[12]; //convert point to string val
			for (int i = 0; i < 12; i++) {
				oldString[i] = interString[i]; //copy
			}
	
			sprintf(interString, "SCORE: %d", point);
			delay(3);
			//fillScreenDMA(bgcolor);
			//waitForVBlank();
			//erase
			//fillScreenDMA(bgcolor);
			//we draw our logo
			drawImageDMA(20, HEIGHT/2, TRADEMARKLOGO_WIDTH, TRADEMARKLOGO_HEIGHT, trademarklogo);
			
			
			drawString(20, 20, oldString, bgcolor); //clear
			waitForVBlank();
			drawString(20, 20, interString, YELLOW);
			
			
			//drawString(20, 20, oldString, bgcolor);



			obp = &ps.balls;
			drawRectDMA(obp->row, obp->col, ps.size, ps.size, bgcolor);
			//waitForVBlank();
			op = &bps.bases;
			drawRectDMA(op->row, op->col, bps.colDim, bps.rowDim, bgcolor);
			//draw
			//
			//
			p = &bcs.bases;
			drawRectDMA(p->row, p->col, bcs.colDim, bcs.rowDim, p->color);

		
			bp = &cs.balls;
			drawRectDMA(bp->row, bp->col, cs.size, cs.size, bp->color);
	
			//waitForVBlank();
			//p = &bcs.bases;
			//drawRectDMA(p->row, p->col, bcs.colDim, bcs.rowDim, p->color);
			break;

		case END:
			
			//erase
			/* //should do before state = end
			obp = &ps.balls;
			drawRectDMA(obp->row, obp->col, ps.size, ps.size, bgcolor);
			op = &bps.bases;	
			drawRectDMA(op->row, op->col, bps.colDim, bps.rowDim, bgcolor);

			*/
			waitForVBlank();

			if (status == 0) {
				drawFullScreenImageDMA(trollface);
				status = 1;
			}

			char finalString[12];
			sprintf(finalString, "SCORE: %d", point);
			
				
		
		
		
			if (KEY_DOWN(BUTTON_SELECT, currentButton)) {
				state = START;
				break;
			}
			waitForVBlank();		
			drawString(20, WIDTH/2 + 50, "GAME OVER", BLACK);
			drawString(HEIGHT/2, WIDTH/2 + 50, finalString, BLACK); 
			//waitForVBlank();
			//setPixel(HEIGHT/2, WIDTH/2, WHITE);
		
			//status = 1; //this is so it exits out the loop and goes thru end again
			//else the screen will freeze and keep drawing it seems
			
			
				
			break;
		}
		previousButton = currentButton;
  }
  UNUSED(previousButton);

 
  return 0;

}
